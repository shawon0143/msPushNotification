'use strict';
const SchemaValidator = require('./schemaValidator.class');

class SchemaObject {
    constructor(schema) {       // 0 => errorMsg
        // 1 => schema NAME not necssary, just use ist
        // > 1 parameters => load schema, last is the master! { schemaName: schema },  schemaName: schema }

        this.alwaysCheck = false;
        this.printErrorMessages = true;
        this.printWarningMessages = false;

        this.schemaValidator = new SchemaValidator();
        if (arguments.length === 0) {
            console.log('least one schema');
        } else if (arguments.length === 1) {
            this.schemaValidator.addSchema('masterSchema', schema);  // key schemaName, value schema
        } else {
            for (let i = 0, len = arguments.length; i < len; i++) {
                let key = Object.keys(arguments[i]);
                if (i === len - 1) {
                    this.schemaValidator.addSchema('masterSchema', arguments[i][key]);  // key schemaName, value schema
                } else {
                    this.schemaValidator.addSchema(key, arguments[i][key]);  // key schemaName, value schema
                }
            }
        }

        this.value = null;
        this.valueCopy = null;
        this.nextValidate = true;
    }

    options(settings) {
        this.alwaysCheck = (typeof settings.alwaysCheck !== 'undefined') ? settings.alwaysCheck : this.alwaysCheck;
        this.printErrorMessages = (typeof settings.printErrorMessages !== 'undefined') ? settings.printErrorMessages : this.printErrorMessages;
        this.printWarningMessages = (typeof settings.printWarningMessages !== 'undefined') ? settings.printWarningMessages : this.printWarningMessages;
    }

    set(value) {
        this.value = value;
        this.nextValidate = true;
    }

    /*    modify(path, value) {

            let deep_value = function(obj, objectPath){
                let path = objectPath.split('.');
                for (let i = 0, len = path.length; i < len; i++) {
                    obj = obj[path[i]];
                }
                return obj;
            };


            let modPart = deep_value(this.value, path);
            console.log(modPart);

            if (typeof modPart !== 'undefined') {
                return false;
            } else {
                modPart = value;
                return true;
            }
            //this.value[path] = value;
        }*/

    get() {
        if (this.nextValidate) {
            let err = [],
                warn = [];

            this.schemaValidator.validateObject('masterSchema', this.value, err, warn);

            if (err.length > 0) {
                if (this.printErrorMessages) {
                    console.log(err);
                }

                return null;
            } else {
                if (warn.length > 0 && this.printWarningMessages) {
                    console.log(warn);
                }

                this.nextValidate = this.alwaysCheck;
                return this.value;
            }

        } else {
            return this.value;
        }
    }
}

module.exports = SchemaObject;
