'use strict';

const checkRule = require('./checkRule'),
    convertValue = require('./checkRule').convertValue,
    util = require('util'),
    extend = util._extend;

/*
 schemaName = string => must loaded before
 schemaName = object => instant check during object
 */

let validCheckOperators = ['=', '!=', '<', '>'];

function checkCondition(conditionText, checkObject, schemaToNow) {
    if (conditionText === null || conditionText.length === 0) {
        return true;
    }

    var result = true;
    var andConditions = conditionText.split(' and ');
    for (let andIdx = 0; andIdx < andConditions.length; andIdx++) {
        result = false;
        conditionText = andConditions[andIdx].trim();

        //string check for each possible operator, fast enough way in this simple condition check, enhance to other method if complexity increases (more operators, and/or, brackets...)
        for (let j = 0; j < validCheckOperators.length; j++) {
            let operatorPos = conditionText.indexOf(validCheckOperators[j]);
            if (operatorPos > -1) {
                let operator = validCheckOperators[j];
                let fieldName = conditionText.substring(0, operatorPos).trim();
                let condition = conditionText.substring(operatorPos + operator.length).trim();
                var checkValue = checkObject[fieldName];
                if (typeof checkValue === 'undefined') {
                    var defaultField = schemaToNow[fieldName];
                    if (typeof defaultField !== 'undefined' && typeof defaultField.default !== 'undefined') {
                        checkValue = defaultField.default;
                    }
                }

                switch (operator) {
                    case '=':
                        if ('' + checkValue === '' + condition) { //compare as string
                            result = true;
                        }

                        break;
                    case '!=':
                        if ('' + checkValue !== '' + condition) { //compare as string
                            result = true;
                        }

                        break;
                    case '<':
                        if (parseInt(checkValue) < parseInt(condition)) { //compare as int
                            result = true;
                        }

                        break;
                    case '>':
                        if (parseInt(checkValue) > parseInt(condition)) { //compare as int
                            result = true;
                        }

                        break;
                }
                if (result) {
                    break;
                }
            }
        }

        if (!result) { //no need to check additional AND conditions
            return false;
        }
    }

    return result;
}

function validateObject(schemaName, object, loadedSchemas, errors, warnings, removeUnknownFields) {

    if (typeof removeUnknownFields === 'undefined') {
        removeUnknownFields = false;
    }

    let schema = {};
    if (typeof schemaName === 'string') {
        var schemaArray = schemaName.split(',');
        for (let i = 0; i < schemaArray.length; i++) {
            let singleSchemaName = schemaArray[i].trim();
            let onPosition = singleSchemaName.toLowerCase().indexOf(' on ');
            let conditionText = null;
            if (onPosition > 1) {
                conditionText = singleSchemaName.substring(onPosition + 4).trim();
                singleSchemaName = singleSchemaName.substring(0, onPosition).trim();
            }

            if (typeof loadedSchemas[singleSchemaName] === 'undefined') {
                errors.push(`Schema ${singleSchemaName} unknown`);
                return false;
            }

            if (checkCondition(conditionText, object)) {
                extend(schema, loadedSchemas[singleSchemaName]);
                if (schema.includeSchema) {
                    var includeSchemaArray = schema.includeSchema.split(',');
                    for (let includeIdx = 0; includeIdx < includeSchemaArray.length; includeIdx++) {
                        let singleIncludeSchemaName = includeSchemaArray[includeIdx].trim();
                        let onPosition = singleIncludeSchemaName.toLowerCase().indexOf(' on ');
                        let conditionText = null;
                        if (onPosition > 1) {
                            conditionText = singleIncludeSchemaName.substring(onPosition + 4).trim();
                            singleIncludeSchemaName = singleIncludeSchemaName.substring(0, onPosition).trim();
                        }

                        if (typeof loadedSchemas[singleIncludeSchemaName] === 'undefined') {
                            errors.push(`Schema to include ${singleIncludeSchemaName} unknown`);
                            return false;
                        }

                        if (checkCondition(conditionText, object, schema)) {
                            extend(schema, loadedSchemas[singleIncludeSchemaName]);
                        }
                    }
                }
            }
        }
    } else {
        schema = schemaName;
    }

    for (let schemaFieldName in schema) {
        let singleField = schema[schemaFieldName];
        if (typeof singleField.default !== 'undefined') {
            if (typeof object[schemaFieldName] === 'undefined') {
                object[schemaFieldName] = convertValue(singleField.default, singleField.type);
            }
        }
    }

    if (typeof object !== 'object') {
        errors.push(`${object} is not an object`);
        return false;
    }

    for (let fieldName in object) {
        if (typeof schema[fieldName] === 'undefined') {
            if (removeUnknownFields) {
                delete object[fieldName];
            } else {
                warnings.push(`field ${fieldName} not defined in schema ${schemaName}`);
            }

            continue;
        }

        var singleSchema = schema[fieldName];

        let fieldValue = object[fieldName];

        if (typeof (fieldValue) === 'undefined') {
            continue;
        }

        if (schema[fieldName].type === 'schema') {
            validateObject(singleSchema.schema, fieldValue, loadedSchemas, errors, warnings, removeUnknownFields);
        } else if (singleSchema.type === 'array') {
            if (!Array.isArray(fieldValue)) {
                errors.push(`${fieldName} is not an array`);
            } else {
                if (singleSchema.max !== 'undefined' && fieldValue.length > singleSchema.max) {
                    errors.push(`${fieldName} array too large ${fieldValue.length} > max ${singleSchema.max}`);
                    continue;
                }

                if (singleSchema.min !== 'undefined' && fieldValue.length < singleSchema.min) {
                    errors.push(`${fieldName} array too small ${fieldValue.length} < min ${singleSchema.min}`);
                    continue;
                }

                for (let i = 0; i < fieldValue.length; i++) {
                    if (singleSchema.arrayType === 'schema') {
                        validateObject(singleSchema.schema, fieldValue[i], loadedSchemas, errors, warnings, removeUnknownFields);
                    } else {
                        let convertedValue = checkRule(
                            { require: singleSchema.require, type: singleSchema.arrayType, max: singleSchema.valueMax, min: singleSchema.valueMin, regEx: singleSchema.valueRegEx },
                            fieldValue[i], fieldName, schema.__convertTypes, errors);
                        if (convertedValue) {
                            object[fieldName] = convertedValue;
                        }
                    }
                }
            }
        } else {
            let convertedValue = checkRule(singleSchema, fieldValue, fieldName, schema.__convertTypes, errors);
            if (convertedValue) {
                object[fieldName] = convertedValue;
            }
        }
    }

    for (let schemaFieldName in schema) {
        let singleField = schema[schemaFieldName];
        if (singleField.require) {
            if (typeof object[schemaFieldName] === 'undefined') {
                errors.push(`required field ${schemaFieldName} not found`);
            }
        }
    }

    return (!(errors && errors.length > 0));
}

module.exports = validateObject;

