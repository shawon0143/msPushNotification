'use strict';

const fs = require('fs'),
    colors = require('colors'),
    moment = require("moment"),
    logType = ['emerg', 'alert', 'crit', 'err', 'warning', 'notice', 'info', 'debug', 'dev'],
    LOG_EMERG = 1,        // Should be corrected immediately, An example might be the loss of the primary ISP connection.
    LOG_ALERT = 1,        // Should be corrected immediately, An example might be the loss of the primary ISP connection.
    LOG_CRIT = 2,         // May be used to indicate a failure in the system's primary application.
    LOG_ERR = 3,          // An application has exceeded it file storage limit and attempts to write are failing.
    LOG_WARN = 4,         // May indicate that an error will occur if action is not taken, For example a non-root file system has only 2GB remaining .
    LOG_NOTICE = 5,       // Events that are unusual but not error conditions .
    LOG_INFO = 6,         // Normal operational messages -no action required. Example an application has started, paused or ended successfully.
    LOG_DEBUG = 7,          // Info useful to developers for debugging the application.
    LOG_DEV = 8;          // special view during developing

class Log {
    constructor (options) {
        this.options = {};
        this.options.logLevel = (options && options.logLevel) ? options.logLevel : LOG_DEBUG;
        this.options.display = (options && options.display) ? options.display : true;
        this.options.writeFile = false;
        this.options.logDateFormat = (options && options.logDateFormat) ? options.logDateFormat : 'MMM DD HH:mm:ss';

        if (options && options.logFile) {
            this.options.logFile = options.logFile;
            this.options.writeFile = true;
        }

        if (options && options.errorLogFile) {
            this.options.errorLogFile = options.errorLogFile;
            this.options.writeFile = true;
        }

    }

    plain(content) {
        process.stdout.write(content);
    }

    emerg (content) {
        msgDispatcher (LOG_EMERG, content, this.options);
    }

    alert (content) {
        msgDispatcher (LOG_ALERT, content, this.options);
    }

    crit (content) {
        msgDispatcher (LOG_CRIT, content, this.options);
    }

    error (content) {
        msgDispatcher (LOG_ERR, content, this.options);
    }

    err (content) {
        msgDispatcher (LOG_ERR, content, this.options);
    }

    warn (content) {
        msgDispatcher (LOG_WARN, content, this.options);
    }

    warning (content) {
        msgDispatcher (LOG_WARN, content, this.options);
    }

    notice (content) {
        msgDispatcher (LOG_NOTICE, content, this.options);
    }

    info (content) {
        msgDispatcher (LOG_INFO, content, this.options);
    }

    debug (content) {
        msgDispatcher (LOG_DEBUG, content, this.options);
    }

    dev (content) {
        msgDispatcher (LOG_DEV, content, this.options);
    }

    writeLog (file, content) {

        fs.appendFile(file, getLogLine(content, this.options), (err) => {
            if (err) {
                this.err('Could not write log file '  + err);
            }
        });
    }

    dailyLog (fileName, content) {

        var date = moment(new Date()).format("YYMMDD"),
            file = fileName + '_' + date;

        fs.appendFile(file, getLogLine(content, this.options), (err) => {
            if (err) {
                this.err('Could not write log file '  + err);
            }
        });
    }
}

/*
 error msg will go to erroLogFile if is set, then will go to logFile
 other msg will go to logFile if is set, otherwise ignore
 */

function toHex(d) {
    return  ("0"+(Number(d).toString(16))).slice(-2).toUpperCase()
}

function showBufferContentAsString(buf) {
    let string = '<Buffer ',
        endString = '>',
        len = buf.length;

    if (len > 20) {
        len = 20;
        endString = ' ... >'
    }

    for (let i = 0; i < len; i++) {
        string = string + toHex(buf[i]) + ' ';
    }

    string = string.substring(0,string.length-1) + endString;
    return string;

}


function msgDispatcher(logLevel, content, options) {
    display (logLevel, content, options);
    write (logLevel, content, options);
}

function write (logLevel, content, options) {
    if (options.writeFile) {
        var logLine = '',
            now = moment(new Date()).format(options.logDateFormat);

        if (typeof content === 'object') {
            if (content instanceof Buffer ) {
                logLine = getLogLine(showBufferContentAsString(content), options, logLevel);
            } else {
                logLine = getLogLine(JSON.stringify(content), options, logLevel);
            }
        } else {
            logLine = getLogLine(content, options, logLevel);
        }

        if (logLevel < 4 ) {
            var logFile = '';
            if (options.errorLogFile) {
                logFile = options.errorLogFile;
            } else {
                logFile = options.logFile;
            }
            fs.appendFile(logFile, logLine, function (err) {
                if (err) console.log('Could not write log file ' + err);
            });
        } else {
            if (options.logFile) {
                fs.appendFile(options.logFile, logLine, function (err) {
                    if (err) console.log('Could not write log file ' + err);
                });
            }
        }
    }
}

function display(logLevel, content, options) {

    var logLine = '';
    if (options.display && options.logLevel >= logLevel) {
        if (typeof content === 'object') {
            if (content instanceof Buffer ) {
                logLine = getLogLine(showBufferContentAsString(content), options, logLevel);
            } else {
                logLine = getLogLine(JSON.stringify(content), options, logLevel);
            }
        } else {
            logLine = getLogLine(content, options, logLevel);
        }


        if (logLevel < 4) {
            process.stderr.write(logLine.red);
        } else {
            if (logLevel === 7) {
                process.stdout.write(logLine.yellow);
            } else if (logLevel === 8) {
                process.stdout.write(logLine.yellow);
            } else {
                process.stdout.write(logLine);
            }
        }
    }
}

// helper function to get allways the same output line
function getLogLine(content, options, logLevel) {
    var now = moment(new Date()).format(options.logDateFormat),
        logLevelText = (logLevel) ? ` [${logType[logLevel]}]` : '',
        logLine = `${now}${logLevelText} ${content} \n`;

    return logLine;
}

//module.exports = Log;

var logInstance = null;

function initInstance(param) {
    logInstance = new Log(param);
    return logInstance;
}

function getInstance(create, createOptions) {
    if (logInstance == null) {
        if (create) {
            return initInstance(createOptions);
        } else {
            return null;
        }

    } else {
        return logInstance;
    }
}

module.exports = Log;
module.exports.getInstance = getInstance;
module.exports.create = initInstance;