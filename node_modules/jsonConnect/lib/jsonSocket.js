'use strict';

const util = require('util'),
    SchemaValidator = require('schemaValidator'),
    shortid = require('shortid');

//    stream = require('stream');

class ConnectionData {
    constructor (socket, parentJsonSocket, webSocket) {
        this.socket = socket;
        this.parentJsonSocket = parentJsonSocket;
        this.webSocket = webSocket;
        this.actualRequestId = 1;
        this.openRequestCallbacks = {};
        this.requestInfos = {};

        this.appendWarnings = {};
        this.responseSchemas = {};

        this.logId = shortid.generate();

        this.intentionallyDisconnected = false;
        this.connected = false;

        this.connectionType = 'none';
    }

    sendRequest(command, params, callbackOnAnswer, appendBinary, timeoutMilliseconds) {
        console.log('send request', command, params);
        this.parentJsonSocket.sendRequest(this, command, params, callbackOnAnswer, appendBinary, timeoutMilliseconds);
    }

    sendRequestPromise(command, params, appendBinary, timeoutMilliseconds) {
        return this.parentJsonSocket.sendRequestPromise(this, command, params, appendBinary, timeoutMilliseconds);
    }

    sendResponse(responseId, errorCode, params, appendBinary) {
        this.parentJsonSocket.sendResponse(this, responseId, errorCode, params, appendBinary);
    }

    disconnect() {
        this.parentJsonSocket.disconnect(this);
    }

    getIp() {
        if (this.socket) {
            return this.socket.remoteAddress;
        } else if (this.webSocket && this.webSocket._socket) {
            return this.webSocket._socket.remoteAddress;
        }
    }

    getConnectionType() {
        return this.connectionType;
    }

}

function nextFunction(json, connectionData, functionData) {
    if (functionData) {
        functionData.callFunction(json, connectionData, nextFunction.bind(null, json, connectionData, functionData.nextFunctionData));
    }
}

var FunctionData = function (callFunction) {
    this.callFunction = callFunction;
    this.nextFunctionData = null;
};

class JsonSocket {
    constructor(config, onUnknownCommandFunction) {
        this.config = config;
        this.onDisconnect = null;
        this.onUnknownCommandFunction = onUnknownCommandFunction;

        this.commandList = {};

        this.schemaValidator = null;
        this.commandSchemas = {};
        this.schemas = {};

        this.disconnectTimeout = 0;
        this.sendTimeout = 0;

        this.removeResponseFieldsNotInSchema = false;
        this.disconnectOnSendTimeout = true;

        this.openSendCount = 0;
        this.openSendBytes = 0;
        this.openBinariesStreamsCount = 0;

        if (config.logInstance) {
            this.log = config.logInstance;
        } else if (config.log) {
            this.log = config.log;
        } else {
            var logLevel = (config.logLevel) ? config.logLevel : 7;
            var logFile = (config.logFile) ? config.logFile : null;
            this.log = require('log').create({ logLevel: logLevel, logFile: logFile });
        }
    }

    setRemoveResponseFieldsNotInSchema(value) {
        this.removeResponseFieldsNotInSchema = value;
    }

    setDisconnectOnSendTimeout(value) {
        this.disconnectOnSendTimeout = value;
    }

    setDisconnectTimeout(milliseconds) {
        this.disconnectTimeout = milliseconds;
    }

    setSendTimeout(milliseconds) {
        this.sendTimeout = milliseconds;
    }

    setOnDisconnect(onDisconnectCallback) {
        this.onDisconnect = onDisconnectCallback;
    }

    setSocketConfigAndEvents(connectionData) {
        connectionData.receiveMessageLength = 0;
        connectionData.receiveBuffer = Buffer.alloc(0);
        connectionData.appendBinaryCount = 0;
        connectionData.appendCallFunction = null;
        connectionData.appendJson = null;

        let _this = this;

        function wsHeartbeat() {
            clearTimeout(connectionData.wsDisconnectTimer);
            connectionData.wsDisconnectTimer = setTimeout(() => {
                connectionData.webSocket.terminate();
            }, _this.disconnectTimeout);
        }

        if (connectionData.socket) {
            connectionData.connectionType = 'jsonSocket';
            connectionData.socket.setNoDelay(true);
            connectionData.socket.setEncoding('binary');
            connectionData.socket.on('data', this.incomingData.bind(this, connectionData));
            connectionData.socket.on('end', this.handleDisconnect.bind(this, connectionData));
            connectionData.socket.on('error', this.handleDisconnect.bind(this, connectionData));
            connectionData.socket.on('close', this.handleDisconnect.bind(this, connectionData));

            if (this.disconnectTimeout > 0) {
                connectionData.socket.setTimeout(this.disconnectTimeout);
                connectionData.socket.on('timeout', this.handleTimeout.bind(this, connectionData));
            }
        } else if (connectionData.webSocket) {
            connectionData.connectionType = 'webSocket';
            connectionData.webSocket.on('message', this.incomingData.bind(this, connectionData));
            connectionData.webSocket.on('close', this.handleDisconnect.bind(this, connectionData));

            if (this.disconnectTimeout > 0) {
                wsHeartbeat();
                connectionData.webSocket.on('message', wsHeartbeat);
                connectionData.webSocket.on('ping', wsHeartbeat);
                connectionData.webSocket.on('close', () => {
                    clearTimeout(connectionData.wsDisconnectTimer);
                });

            }
        }
    }

    sendWriteCallback(bytes) {
        this.openSendCount--;
        this.openSendBytes -= bytes;
    }

    checkSchema(connectionData, json, responseId, errors, warnings) {
        if (!this.schemaValidator) {
            return true;
        } else {
            if (responseId) {
                let commandSchema = connectionData.responseSchemas['_' + responseId];
                if (commandSchema) {
                    delete connectionData.responseSchemas['_' + responseId];
                }

                if (commandSchema && commandSchema.responseSchema) {
                    return this.schemaValidator.validateObject(commandSchema.responseSchema, json, errors, warnings, this.removeResponseFieldsNotInSchema);
                } else {
                    errors.push('no responseSchema defined');
                    return false;
                }
            } else {
                let commandSchema = this.commandSchemas[json.command];
                if (commandSchema && commandSchema.requestSchema) {
                    if (json.requestId) {
                        connectionData.responseSchemas['_' + json.requestId] = commandSchema;
                    }

                    return this.schemaValidator.validateObject(commandSchema.requestSchema, json, errors, warnings);
                } else {
                    errors.push('no requestSchema for command ' + json.command);
                    return false;
                }
            }
        }
    }

    handleTimeout(connectionData, data) {
        connectionData.socket.destroy();
    }

    incomingData(connectionData, data) {
        if (typeof data === 'string') {
            data = Buffer.from(data, 'binary');
        }

        connectionData.receiveBuffer = Buffer.concat([connectionData.receiveBuffer, data]);

        while (connectionData.receiveBuffer.length > 0) {
            if (connectionData.receiveMessageLength === 0 && connectionData.receiveBuffer.length > 3) {
                connectionData.receiveMessageLength = (connectionData.receiveBuffer.readUInt8(0)) +
                    (connectionData.receiveBuffer.readUInt8(1) << (8 * 1)) +
                    (connectionData.receiveBuffer.readUInt8(2) << (8 * 2)) +
                    (connectionData.receiveBuffer.readUInt8(3) << (8 * 3));
                connectionData.receiveBuffer = connectionData.receiveBuffer.slice(4);
                if (connectionData.receiveMessageLength === 0) {
                    connectionData.socket.close();
                    break;
                }
            }

            if (connectionData.receiveMessageLength > 0 && connectionData.receiveBuffer.length >= connectionData.receiveMessageLength) {
                try {
                    if (connectionData.appendBinaryCount > 0) {
                        let message = connectionData.receiveBuffer.slice(0, connectionData.receiveMessageLength);
                        connectionData.appendBinaryCount -= 1;

                        connectionData.appendJson.binaries.push(message);
                        if (connectionData.appendBinaryCount === 0) {
                            if (connectionData.appendJson.responseId) {
                                if (connectionData.appendCallFunction) {
                                    setImmediate(connectionData.appendCallFunction, connectionData.appendJson, connectionData, connectionData.appendJson.errorCode);
                                    delete connectionData.openRequestCallbacks['_' + connectionData.appendJson.responseId.toString()];
                                }
                            } else {
                                if (connectionData.appendCallFunction) {
                                    let errors = [];
                                    let warnings = [];
                                    if (this.checkSchema(connectionData, connectionData.appendJson, null, errors, warnings)) {
                                        if (warnings.length > 0) {
                                            connectionData.appendWarnings['_' + connectionData.appendJson.requestId] = warnings;
                                        }

                                        setImmediate(connectionData.appendCallFunction.callFunction, connectionData.appendJson, connectionData,
                                            nextFunction.bind(null, connectionData.appendJson, connectionData, connectionData.appendCallFunction.nextFunctionData));
                                    } else {
                                        this.sendResponse(connectionData, connectionData.appendJson.requestId, -2, { errors: errors, warnings: warnings }, null, true);
                                    }
                                } else {
                                    this.onUnknownCommandFunction(connectionData.appendJson, connectionData);
                                }
                            }
                        }
                    } else {
                        let message = connectionData.receiveBuffer.slice(0, connectionData.receiveMessageLength).toString();
                        var json = JSON.parse(message);

                        connectionData.appendBinaryCount = 0;

                        if (json.appendedBinaries && json.appendedBinaries > 0) {
                            connectionData.appendBinaryCount = json.appendedBinaries;
                        }

                        if (json.responseId) {
                            var requestInfos = connectionData.requestInfos['_' + json.responseId];
                            if (requestInfos) {
                                this.log.debug(`[${connectionData.logId}_${json.responseId}] received response in ${new Date().getTime() - requestInfos.startTime} ms ${message.substr(0, 100).replace(/\n/g, '')}`);
                            }

                            let callFunction = connectionData.openRequestCallbacks['_' + json.responseId];
                            if (connectionData.appendBinaryCount > 0) {
                                connectionData.appendCallFunction = callFunction;
                                connectionData.appendJson = json;
                                connectionData.appendJson.binaries = [];
                            } else {
                                if (callFunction) {
                                    setImmediate(callFunction, json, connectionData, json.errorCode);
                                    delete connectionData.openRequestCallbacks['_' + json.responseId];
                                }
                            }

                            if (requestInfos) {
                                if (requestInfos.sendTimer) {
                                    clearTimeout(requestInfos.sendTimer);
                                }

                                delete connectionData.requestInfos['_' + json.responseId];
                            }
                        } else {
                            this.log.debug(`[${connectionData.logId}_${json.requestId}] received request ${message.substr(0, 100).replace(/\n/g, '')}`);

                            let callFunction = this.commandList[json.command];
                            if (connectionData.appendBinaryCount > 0) {
                                connectionData.appendCallFunction = callFunction;
                                connectionData.appendJson = json;
                                connectionData.appendJson.binaries = [];
                            } else {
                                if (callFunction) {
                                    let errors = [];
                                    let warnings = [];

                                    connectionData.requestInfos['_' + json.requestId] = { startTime: new Date().getTime() };

                                    if (this.checkSchema(connectionData, json, null, errors, warnings)) {
                                        if (warnings.length > 0) {
                                            connectionData.appendWarnings['_' + json.requestId] = warnings;
                                        }

                                        setImmediate(callFunction.callFunction, json, connectionData, nextFunction.bind(null, json, connectionData, callFunction.nextFunctionData));
                                    } else {
                                        this.sendResponse(connectionData, json.requestId, -2, { errors: errors, warnings: warnings }, null, true);
                                    }
                                } else {
                                    this.onUnknownCommandFunction(json, connectionData);
                                }
                            }
                        }
                    }
                }
                catch (e) {
                    console.log(e);
                }

                connectionData.receiveBuffer = connectionData.receiveBuffer.slice(connectionData.receiveMessageLength);
                connectionData.receiveMessageLength = 0;
            } else {
                break;
            }
        }
    }

    handleDisconnect(connectionData) {
        if (connectionData.connected) {
            connectionData.connected = false;
            if (this.onDisconnect) {
                this.onDisconnect(connectionData, connectionData.intentionallyDisconnected);
            }

            connectionData.intentionallyDisconnected = false;

            for (let key in connectionData.openRequestCallbacks) {
                var callFunction = connectionData.openRequestCallbacks[key];
                if (callFunction) {
                    setImmediate(callFunction, { errorCode: -1 }, connectionData, -1);
                }
            }

            for (let key in connectionData.requestInfos) {
                var requestInfos = connectionData.requestInfos[key];
                if (requestInfos && requestInfos.sendTimer) {
                    clearTimeout(requestInfos.sendTimer);
                }
            }

            connectionData.openRequestCallbacks = {};
            connectionData.requestInfos = {};
        }
    }

    setCommandsAndSchemas(settings, commands, schemas) {
        this.schemaValidator = new SchemaValidator(settings.warningMode, this.log);

        for (let i = 0; i < schemas.length; i++) {
            let schema = schemas[i];
            for (let schemaName in schema) {
                let schemaParams = schema[schemaName];
                if (!schemaParams) {
                    schemaParams = {};
                }

                schemaParams.command = { require: false, type: 'string' };
                schemaParams.requestId = { require: false, type: 'number' };
                schemaParams.errors = { require: false, type: 'array', arrayType: 'string' };
                schemaParams.warnings = { require: false, type: 'array', arrayType: 'string' };
                schemaParams.appendedBinaries = { require: false, type: 'number' };
                schemaParams.binaries = { require: false, type: 'ignore' };
                this.schemaValidator.addSchema(schemaName, schemaParams);
            }
        }

        for (let i = 0; i < commands.length; i++) {
            let command = commands[i];
            let commandName = command.command;
            let commandRequestSchema = null;
            let commandResponseSchema = null;

            if (command.schemaRequest) {
                commandRequestSchema = command.schemaRequest;
            }

            if (command.schemaResponse) {
                commandResponseSchema = command.schemaResponse;
            }

            this.commandSchemas[commandName] = { requestSchema: commandRequestSchema, responseSchema: commandResponseSchema };
        }
    }

    registrateCommand(command, callFunctions) {
        var args = [];
        for (var i = 1; i < arguments.length; i++) {
            args.push(arguments[i]);
        }

        var functionCount = 0;
        var lastFunctionData = null;
        while (args.length > 0) {
            var func = args.shift();
            var functionData = new FunctionData(func);
            if (functionCount === 0) {
                this.commandList[command] = functionData;
            }

            if (lastFunctionData) {
                lastFunctionData.nextFunctionData = functionData;
            }

            functionCount++;
            lastFunctionData = functionData;
        }
    }

    appendBinaryInParams(params, appendBinary) {
        if (appendBinary) {
            if (Array.isArray(appendBinary)) {
                params.appendedBinaries = appendBinary.length;
            } else {
                params.appendedBinaries = 1;
            }
        }
    }

    sendBinaryToSocket(connectionData, appendBinary) {

        /*function readStreamDataEvent(data) {
            try {
                this.openSendCount += 1;
                socket.write(data, this.sendWriteCallback.bind(this, data.length));
            }
            catch (ex) {
                console.log(ex);
            }
        }

        function endStreamEvent(data) {
            this.openSendCount -= 1;
            this.openBinariesStreamsCount -= 1;
        }*/

        if (appendBinary) {

            if (Array.isArray(appendBinary)) {
                for (let i = 0; i < appendBinary.length; i++) {
                    let sendBuffer = appendBinary[i];
                    if (!Buffer.isBuffer(sendBuffer) && typeof sendBuffer === 'object') {
                        this.log.error('send binary stream is disabled in jsonSocket (errors on parallel sending)');
                        this.closeConnection(connectionData);
                        /*if (sendBuffer.stream instanceof stream.Readable && typeof sendBuffer.length !== 'undefined') {
                            let appendLengthBuffer = new Buffer(4);
                            this.openSendCount += 2; //the second is decreased on endStreamEvent
                            this.openSendBytes += 4 + sendBuffer.length;
                            appendLengthBuffer.writeInt32LE(sendBuffer.length, 0);

                            socket.write(appendLengthBuffer, this.sendWriteCallback.bind(this, 4));
                            this.openBinariesStreamsCount += 1;
                            sendBuffer.stream.on('data', readStreamDataEvent.bind(this));
                            sendBuffer.stream.on('end', endStreamEvent.bind(this));
                            sendBuffer.stream.resume();
                        } else {
                            this.log.warning('trying to send invalid binary data');
                        }*/
                    } else {
                        let appendLengthBuffer = Buffer.alloc(4);
                        this.openSendCount += 2;
                        this.openSendBytes += 4 + sendBuffer.length;
                        appendLengthBuffer.writeInt32LE(sendBuffer.length, 0);
                        this.sendData(connectionData, appendLengthBuffer);
                        this.sendData(connectionData, sendBuffer);
                    }
                }
            } else {
                let appendLengthBuffer = Buffer.alloc(4);
                let sendBuffer = appendBinary;
                this.openSendCount += 2;
                this.openSendBytes += 4 + sendBuffer.length;
                appendLengthBuffer.writeInt32LE(sendBuffer.length, 0);
                this.sendData(connectionData, appendLengthBuffer);
                this.sendData(connectionData, sendBuffer);
            }
        }
    }

    handleSendTimeout(connectionData, requestId) {
        var requestInfos = connectionData.requestInfos['_' + requestId];
        if (requestInfos) {
            this.log.crit(`[${connectionData.logId}_${requestId}] requestId ${requestId} timed out after ${new Date().getTime() - requestInfos.startTime} ms`);
            if (this.disconnectOnSendTimeout) {
                this.log.crit(`[${connectionData.logId}_${requestId}] close connection`);
                this.closeConnection(connectionData);
            } else {
                let callFunction = connectionData.openRequestCallbacks['_' + requestId];
                if (callFunction) {
                    setImmediate(callFunction, { errorCode: -5, errMsg: 'request timed out' }, connectionData, -5);
                    delete connectionData.openRequestCallbacks['_' + requestId];
                }
            }
        }
    }

    sendData(connectionData, data) {
        if (connectionData.webSocket) {
            connectionData.webSocket.send(data, this.sendWriteCallback.bind(this, data.length));
        } else {
            connectionData.socket.write(data, this.sendWriteCallback.bind(this, data.length));
        }
    }

    sendRequest(connectionData, command, params, callbackOnAnswer, appendBinary, timeoutMilliseconds) {
        if (!connectionData.connected) {
            callbackOnAnswer({ errorCode: -1 }, connectionData, -1);
            return;
        }

        if (!params) {
            params = {};
        }

        params.command = command;
        params.requestId = connectionData.actualRequestId++;

        this.appendBinaryInParams(params, appendBinary);

        var data = JSON.stringify(params);
        var buffer = Buffer.from(data, 'utf8');

        this.log.debug(`[${connectionData.logId}_${params.requestId}] send request ${data.substr(0, 100).replace(/\n/g, '')}`);

        var messageLengthBuffer = Buffer.alloc(4);
        this.openSendCount += 2;
        this.openSendBytes += 4 + buffer.length;

        messageLengthBuffer.writeInt32LE(buffer.length, 0);
        this.sendData(connectionData, messageLengthBuffer);
        this.sendData(connectionData, buffer);

        this.sendBinaryToSocket(connectionData, appendBinary);

        if (this.debug === 1) {
            console.log(`jsonSocket request: `.yellow  +  data.grey);
        }

        var useTimeout = this.sendTimeout;
        if (timeoutMilliseconds) {
            useTimeout = timeoutMilliseconds;
        }

        var timeoutObject = null;
        if (useTimeout > 0) {
            timeoutObject = setTimeout(this.handleSendTimeout.bind(this, connectionData, params.requestId), useTimeout);
        }

        connectionData.requestInfos['_' + params.requestId] = { startTime: new Date().getTime(), sendTimer: timeoutObject };

        if (callbackOnAnswer) {
            connectionData.openRequestCallbacks['_' + params.requestId] = callbackOnAnswer;
        }
    }

    sendRequestPromise(connectionData, command, params, appendBinary, timeoutMilliseconds) {
        return new Promise((fulfill, reject) => {
            if (typeof appendBinary === 'function') {
                this.log.error('sendRequestPromise with appendBinary as function, old callback style?');
                var result = { errorCode: -1 };
                reject(result);
            }

            this.sendRequest(connectionData, command, params, (result, resultConnectionData) => {
                fulfill(result);
            }, appendBinary, timeoutMilliseconds);
        });
    }

    sendResponse(connectionData, responseId, errorCode, params, appendBinary, isErrorResponse) {
        if (!params) {
            params = {};
        }

        let errors = [];
        let warnings = [];

        params.errorCode = errorCode;

        if (!isErrorResponse) {
            this.checkSchema(connectionData, params, responseId, errors, warnings);
            if (errors.length > 0) {
                this.log.warning('errors in response ' + util.inspect(params) + ': ' + util.inspect(errors));
            }

            if (warnings.length > 0) {
                this.log.warning('warnings in response ' + util.inspect(params) + ': ' + util.inspect(warnings));
            }
        }

        //reset if removed from validation
        params.errorCode = errorCode;

        if (appendBinary) {
            if (Array.isArray(appendBinary)) {
                params.appendedBinaries = appendBinary.length;
            } else {
                params.appendedBinaries = 1;
            }
        }

        params.responseId = responseId;

        let appendWarning = connectionData.appendWarnings['_' + responseId];
        if (appendWarning) {
            params.warnings = appendWarning;
            delete connectionData.appendWarnings['_' + responseId];
        }

        var responseData = JSON.stringify(params);
        var buffer = Buffer.from(responseData);

        var requestInfos = connectionData.requestInfos['_' + params.responseId];
        if (requestInfos) {
            this.log.debug(`[${connectionData.logId}_${params.responseId}] send response after ${new Date().getTime() - requestInfos.startTime} ms  ${responseData.substr(0, 100).replace(/\n/g, '')}`);
        }

        delete connectionData.requestInfos['_' + params.responseId];

        var messageLengthBuffer = Buffer.alloc(4);

        this.openSendCount += 2;
        this.openSendBytes += 4 + buffer.length;

        messageLengthBuffer.writeInt32LE(buffer.length, 0);
        this.sendData(connectionData, messageLengthBuffer);
        this.sendData(connectionData, buffer);

        this.sendBinaryToSocket(connectionData, appendBinary);

        if (this.debug === 1) {
            console.log(`jsonSocket response: `.yellow  +  `${connectionData.socket.remoteAddress}  ${responseData}`.grey);
        }
    }

    disconnect(connectionData) {
        connectionData.intentionallyDisconnected = true;
        this.closeConnection(connectionData);
    }

    closeConnection(connectionData) {
        if (connectionData.webSocket) {
            connectionData.webSocket.close();
        } else {
            connectionData.socket.destroy();
        }
    }
}

module.exports = JsonSocket;
module.exports.ConnectionData = ConnectionData;
