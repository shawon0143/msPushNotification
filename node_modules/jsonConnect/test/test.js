'use strict';

const log = require('log').create({ logLevel: 5 }),
    jsonConnect = require('../index'),
    JsonSocketServer = jsonConnect.server,
    JsonSocketClients = jsonConnect.clients,
    util = require('util'),
    fs = require('fs'),
    serverCommands = require('./serverCommands'),
    yamlParser = require('yamljs'),
    sslUtils = require('ssl-utils'),
    WebSocketServer = require('ws').Server,
    WebSocketClient = require('ws');

const assert = require('assert'),
    expect    = require('chai').expect;
const certs = { sslKey: fs.readFileSync('/etc/letsencrypt/live/dev1.comvalue.com/privkey.pem'), sslCert: fs.readFileSync('/etc/letsencrypt/live/dev1.comvalue.com/fullchain.pem') };

let jsonSocketServer = null,
    clientConnections = {},
    jsonSocketClients = null,
    connectionDataClient1 = null,
    connectionDataClient2 = null,
    connectionDataClient3 = null,
    connectionDataClient4 = null,
    connectionDataClient5 = null,
    connectionDataClient6 = null;

describe('Server JsonSocket & WebSocket', function () {
    it('server start', function () {
        sslUtils.checkCertificateExpiration(certs.sslCert, function (err, certExpiry) {
            log.warning('expireDate: ' + certExpiry);
        });

        jsonSocketServer = new JsonSocketServer({ logLevel: 3, sslKey: certs.sslKey, sslCert: certs.sslCert, logInstance: log }, (json, connectionData) => {
            connectionData.sendResponse(json.requestId, 2, { errorCode: 2, answer: 'unknown command!' });
        });
        jsonSocketServer.setCommandsAndSchemas('strict', yamlParser.load('./test/serverCommands.yml').commands, yamlParser.load('./test/serverSchemas.yml').schemas);
        const wss = new WebSocketServer({ port: 8081 });
        jsonSocketServer.createServer('0.0.0.0', 8001, wss);
    });

    it('registrate commands', function () {
        jsonSocketServer.registrateCommand('login', (json, connectionData) => {
            clientConnections[json.name] = connectionData;
            connectionData.sendResponse(json.requestId, 0, { });
        });

        jsonSocketServer.registrateCommand('ping', serverCommands.ping);
        jsonSocketServer.registrateCommand('pingWrong1', serverCommands.pingWrong1);
        jsonSocketServer.registrateCommand('pingWrong2', serverCommands.pingWrong2);
        jsonSocketServer.registrateCommand('pingWrong3', serverCommands.pingWrong3);
        jsonSocketServer.registrateCommand('testCommand', serverCommands.testCommand);
        jsonSocketServer.registrateCommand('noAnswer', serverCommands.noAnswer);
        jsonSocketServer.registrateCommand('tooMuchFields', serverCommands.tooMuchFields);
        jsonSocketServer.setOnDisconnect(serverCommands.disconnect);

    });
});

for (let typeIndex = 0; typeIndex < 2; typeIndex++) {

    let type = (typeIndex === 0) ? 'JsonSocket' : 'WebSocket';

    describe('Client ' + type, function () {
        describe('Client 1 ' + type, function () {
            it('setup, sendTimeout = 1500ms', () => {
                jsonSocketClients = new JsonSocketClients({logLevel: 3, useTls: true}, (json, connection) => {
                    //    console.log('client unknownCommand');
                });
                jsonSocketClients.setSendTimeout(1500);
                jsonSocketClients.setCommandsAndSchemas('strict', yamlParser.load('./test/clientCommands.yml').commands, yamlParser.load('./test/clientSchemas.yml').schemas);

            });
            it('connect', (done) => {

                function connectionCallback(connected, connection) {
                    assert.equal(connected, true);
                    expect(connected).to.equal(true);
                    connectionDataClient1 = connection;
                    done();
                }

                if (typeIndex === 0) {
                    jsonSocketClients.connect('0.0.0.0', 8001, connectionCallback);
                }
                else {
                    jsonSocketClients.connectWs('http://127.0.0.1:8081', connectionCallback);
                }
            });
            it('login', (done) => {
                connectionDataClient1.sendRequest('login', {name: 'client1'}, (json, resultConnectionData) => {
                    console.log('login result', json,  resultConnectionData.getConnectionType(), resultConnectionData.getIp());
                    expect(json.errorCode).to.equal(0);
                    done();
                });
            });
            it('ping pong', (done) => {
                let pong = 'test test test';
                connectionDataClient1.sendRequest('ping', {pong: pong}, (json, resultConnectionData) => {
                    expect(json.answer).to.equal(pong);
                    // jsonSocketServer.reloadSSLCertificate(certs.sslKey, certs.sslCert);
                    done();
                });
            });
            it('ping pong (promise)', (done) => {
                let pong = 'test test test';
                connectionDataClient1.sendRequestPromise('ping', {pong: pong}).then((result) => {
                    expect(result.answer).to.equal(pong);
                    done();
                });
            });
            it('binaryCommand', () => {
                let testBuffer = new Buffer(0),
                    testBuffer2 = new Buffer(0);

                testBuffer += 'huhu';
                testBuffer2 += '1234567890';
                connectionDataClient1.sendRequest('testCommand', {test: 123}, (json, resultConnectionData) => {
                    expect(json.answer).to.equal('huhu!');
                }, [testBuffer, testBuffer2]);
            });
        });

        describe('Client 2 ' + type, () => {

            it('client connect', (done) => {

                function connectionCallback(connected, connection) {
                    assert.equal(connected, true);
                    connectionDataClient2 = connection;
                    done();
                }

                if (typeIndex === 0) {
                    jsonSocketClients.connect('0.0.0.0', 8001, connectionCallback);
                }
                else {
                    jsonSocketClients.connectWs('http://127.0.0.1:8081', connectionCallback);
                }
            });
            it('login', (done) => {
                jsonSocketClients.sendRequest(connectionDataClient2, 'login', {name: 'client2'}, (json, resultConnectionData) => {
                    done();
                });
            });
            it('ping pong', () => {
                let pong = 'test test test 22222';
                jsonSocketClients.sendRequest(connectionDataClient2, 'ping', {pong: pong}, (json, resultConnectionData) => {
                    expect(json.answer).to.equal(pong);
                });
            });
            it('client request (server send request to client)', (done) => {
                jsonSocketClients.registrateCommand('clientCommand', (json, connectionData) => {
                    expect(json.test).to.equal('test');
                    expect(json.command).to.equal('clientCommand');
                    connectionData.sendResponse(json.requestId, 0, {allright: true});
                });

                clientConnections.client1.sendRequest('clientCommand', {test: 'test'}, (json, connectionData) => {
                    expect(json.allright).to.equal(true);
                    done();
                });
            });
        });
    });

    describe('Validator check ' + type, () => {
        describe('Request ' + type, () => {
            it('without any para', (done) => {
                connectionDataClient2.sendRequest('ping', {}, (json, resultConnectionData) => {
                    expect(json.errorCode).to.equal(-2);
                    expect(json.errors[0]).to.equal('required field pong not found');
                    done();
                });
            });

            it('with too many para', (done) => {
                connectionDataClient2.sendRequest('ping', {
                    pong: 'pong',
                    ping: 'ping'
                }, (json, resultConnectionData) => {
                    expect(json.errorCode).to.equal(-2);
                    expect(json.errors[0]).to.equal('field ping not defined in schema pingRequest');
                    done();
                });
            });

            it('para to short', (done) => {
                connectionDataClient2.sendRequest('ping', {pong: 'pon'}, (json, resultConnectionData) => {
                    //console.log(json);
                    expect(json.errorCode).to.equal(-2);
                    expect(json.errors[0]).to.equal('"pong" too short 3 min: 4');
                    done();
                });
            });

            it('para wrong format', (done) => {
                connectionDataClient2.sendRequest('ping', {pong: 3}, (json, resultConnectionData) => {
                    //console.log(json);
                    expect(json.errorCode).to.equal(-2);
                    expect(json.errors[0]).to.equal('"pong" has an wrong type. should have string -> but is number (3)');
                    done();
                });
            });
        });

        describe('Response (will come warnings in stdout!) ' + type, () => {
            it('without any data', (done) => {
                connectionDataClient2.sendRequest('pingWrong1', {pong: 'hallo'}, (json, resultConnectionData) => {
                    expect(json.errorCode).to.equal(0);
                    expect(json).has.not.property('answer');
                    done();
                });
            });
            it('without wrong format', (done) => {
                connectionDataClient2.sendRequest('pingWrong2', {pong: 'hallo'}, (json, resultConnectionData) => {
                    expect(json.errorCode).to.equal(0);
                    expect(json).has.property('answer');
                    done();
                });
            });

            it('too many data', (done) => {
                connectionDataClient2.sendRequest('pingWrong3', {pong: 'hallo'}, (json, resultConnectionData) => {
                    expect(json.errorCode).to.equal(0);
                    expect(json).has.property('answer');
                    done();
                });
            });

            it('tooMuchFields in answer (no field remove)', (done) => {
                connectionDataClient2.sendRequest('tooMuchFields', {}, (json, resultConnectionData) => {
                    expect(json.errorCode).to.equal(0);
                    expect(json.field3).to.equal('field3');
                    done();
                });
            });

            it('tooMuchFields in answer (remove fields)', (done) => {
                jsonSocketServer.setRemoveResponseFieldsNotInSchema(true);
                connectionDataClient2.sendRequest('tooMuchFields', {}, (json, resultConnectionData) => {
                    jsonSocketServer.setRemoveResponseFieldsNotInSchema(false);
                    expect(json.errorCode).to.equal(0);
                    expect(typeof json.field3).to.equal('undefined');
                    done();
                });
            });
        });
    });

    describe('Disconnect ' + type, () => {
        it('disconnect client 1', (done) => {
            jsonSocketClients.disconnect(connectionDataClient1);
            done();
        });

        it('server send client2 msg', (done) => {
            clientConnections.client2.sendRequest('clientCommand', {test: 'test'}, (json, connectionData) => {        // bleibt hängen wenn client nicht verbunden ist
                expect(json.allright).to.equal(true);
                done();
            });
        });

        it('disconnect client 2', (done) => {
            jsonSocketClients.disconnect(connectionDataClient2);
            done();
        });

        it('server send client2 msg', (done) => {
            clientConnections.client2.sendRequest('clientCommand', {test: 'test'}, (json, connectionData) => {        // bleibt hängen wenn client nicht verbunden ist
                expect(json.errorCode).to.equal(-1);
                done();
            });
        });
    });

    describe('Timout ' + type, () => {
        it('set inactive timeout 1000 ms & client connect 3', (done) => {
            jsonSocketClients.setDisconnectTimeout(1000);

            function connectionCallback(connected, connection) {
                assert.equal(connected, true);
                connectionDataClient3 = connection;
                done();
            }

            if (typeIndex === 0) {
                jsonSocketClients.connect('0.0.0.0', 8001, connectionCallback);
            }
            else {
                jsonSocketClients.connectWs('http://127.0.0.1:8081', connectionCallback);
            }
        });
        it('no answer, inactivity timeout disconnect', (done) => {
            connectionDataClient3.sendRequest('noAnswer', {pong: 'hallo'}, (json, resultConnectionData) => {
                expect(json.errorCode).to.equal(-1);
                done();
            });
        }).timeout(1200);
        it('reset inactive timeout, client connect 4', (done) => {
            jsonSocketClients.setDisconnectTimeout(0);

            function connectionCallback(connected, connection) {
                assert.equal(connected, true);
                connectionDataClient4 = connection;
                done();
            }

            if (typeIndex === 0) {
                jsonSocketClients.connect('0.0.0.0', 8001, connectionCallback);
            }
            else {
                jsonSocketClients.connectWs('http://127.0.0.1:8081', connectionCallback);
            }
        });
        it('no answer, general sendTimeout (is set to 1500ms) disconnect', (done) => {
            connectionDataClient4.sendRequest('noAnswer', {pong: 'hallo'}, (json, resultConnectionData) => {
                expect(json.errorCode).to.equal(-1);
                done();
            });
        });
        it('client connect 5', (done) => {

            function connectionCallback(connected, connection) {
                assert.equal(connected, true);
                connectionDataClient5 = connection;
                done();
            }

            if (typeIndex === 0) {
                jsonSocketClients.connect('0.0.0.0', 8001, connectionCallback);
            }
            else {
                jsonSocketClients.connectWs('http://127.0.0.1:8081', connectionCallback);
            }
        });
        it('no answer, request sendTimeout (750ms) disconnect', (done) => {
            connectionDataClient5.sendRequest('noAnswer', {pong: 'hallo'}, (json, resultConnectionData) => {
                expect(json.errorCode).to.equal(-1);
                done();
            }, null, 750);
        });
        it('client connect 6', (done) => {

            function connectionCallback(connected, connection) {
                assert.equal(connected, true);
                connectionDataClient6 = connection;
                done();
            }

            if (typeIndex === 0) {
                jsonSocketClients.connect('0.0.0.0', 8001, connectionCallback);
            }
            else {
                jsonSocketClients.connectWs('http://127.0.0.1:8081', connectionCallback);
            }
        });
        it('no answer, request sendTimeout (750ms) no disconnect, send ping after timeout', (done) => {
            jsonSocketClients.setDisconnectOnSendTimeout(false);
            connectionDataClient6.sendRequest('noAnswer', {pong: 'hallo'}, (json, resultConnectionData) => {
                expect(json.errorCode).to.equal(-5);
                let pong = 'test test test';
                connectionDataClient6.sendRequest('ping', {pong: pong}, (json, resultConnectionData) => {
                    expect(json.answer).to.equal(pong);
                    done();
                });
            }, null, 750);
        });
    });
}
/*
 jsonSocket:
 - warning wenn befehl registriert wird der nicht im yml steht
 */

